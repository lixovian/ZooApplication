
# Отчет по ДЗ1 - КПО
#### Описание:
Консольное приложение, реализует возможность хранения животных и инвентаря для Московского зоопарка.
Проект разбит на библиотеки, внутри которых данные структурированы по папкам, для поддержания структуры кода. 

#### Управление / интерфейс:
Управление осуществляется посредством ввода с клавиатуры. В частности, используется движение с помощью стрелочек + клавиша Enter для нажатия на кнопки. 
#### Техническая реализация:
Интерфейс IAlive почти не применяется в коде и был заменен на абстрактный класс Animal, так как функционал реализации классов для животных не применим к людям и требует отдельного создания сервисов наподобие тех, что были созданы для животных и инвентаря. Приложение при этом легко масштабируется и добавить новый тип данных будет не проблемой, поэтому это решение не нарушает условия ТЗ.

Проект разбит на несколько библиотек для удобства :
* ApplicationTest -- библиотека Unit-тестов
* DataProcessing -- библиотека хранения и обработки данных о нужных объектах
* ZooObjects - библиотека стандартных реализаций классов животных и инвентаря
* GuiLibrary -- библиотека реализации UI элементов 
* ViewManagerLibrary -- библиотека смены окон консольного приложения

#### Решения, принятые при проектировании

#### GuiLibrary
Библиотека элементов UI. Выполнена по принципам ООП и SOLID. Имеется базовый класс Unit с базовым функционалом отрисовки, от него создаются различные спецификации класса. Unit поддерживает интерактивность, изменение внутренних данных по различным параметрам. За счет этого реализованы раздичные элементы UI, а том числе Button, CheckBox, TextInput и т. д. Также с помощью класса Unit реализованы контейнеры для отображения блоков (сразу нескольких) элементов Unit одновременно горизонтально или вертикально в консоли. 
#### ViewManager
Менеджер окон построен по принципам ООП. Имеется базовый статический класс, который отвечает за добавление новых и переключение между уже существующими окнами, и должен быть доступен из всех частей программы, что оправдывает его статичность. Также имеется базовый класс View, дочерные классы которого отвечают за различные окна консольного приложения. 
#### DataProcessing
Было решено отказаться от реализации отдельных классов ветеринарной клиники и зоопарка. Вместо этого была реализована группа связанных сервисов, которые отвечают за создание, хранение, обработку и отрисовку данных. Список сервисов (данные даны в формате "Интерфейс сервиса", "Имплементация сервиса"):
* Хранение данных
ObjectData<Animal>, AnimalData;
ObjectData<IInventory>, InventoryData;
ObjectData<T> - Generic класс, который отвечает за хранение, добавление и извлечение данных различных типов из списка _data. В классе также реализована возможность валидации данных. Валидация происходит полностью на стороне этого класса, а не на клиентской (клиенту возвращается только ответ функции об успешности добавления данных и, в некоторых случаях, ошибка), так как именно сервисы должны валидировать данные и клиент не должен влиять на это.

* Создание животных
ObjectCreator<IAnimalFabric>, AnimalCreator;
ObjectCreator<IInventoryFabric>, InventoryCreator;
Класс ObjectCreator<T> связывает строковое представление типа объекта с  фабрикой, которая позволяет создавать новые экземпляры объекта.
        
* Вывод данных
IObjectOutput<Animal>, AnimalOutput;
IObjectOutput<IInventory>, InventoryOutput;  
IObjectShortOutput<Animal>, AnimalShortOutput;
IObjectShortOutput<IInventory>, InventoryShortOutput;
Указанные сервисы отвечают за вывод данных об объектах в стандартном и укороченном виде. 

* Фильтр данных
IContactFilter, ContactFilter; - проверка на то, может ли животное быть в контактном зоопарке
IGrassEaterFilter, GrassEaterFilter; - проверка на то, нужен ли растительный корм животному
IMeatEaterFilter, MeatEaterFilter; - проверка на то, нужен ли мясной корм животному
Различные фильтры данных, которые выдают bool ответ в зависимости от параметров животного Animal, который передан в соответствующий аргумент функции

* Сервис получения данных о еде
IAnimalFoodParser, AnimalFoodParser;
Позволяет получить данные о том, сколько еды требуется передаваемому списку животных на день
 
 * Сервис фильтра данных перед выводом в консоль
IDisplayFilter<Animal>, AnimalDisplayFilter;  
IDisplayFilter<IInventory>, InventoryDisplayFilter;  
В данном проекте не применяется и является по сути ширмой, но добавлен на случай машстабизации приложения и необходимости добавления фильтров на вывод данных в консоль (так как московский зоопарк - очень большой)

#### Применение принципов ООП и SOLID
Приниципы ООП, помимо перечисленных выше случаев, применены при:
* Принцип наследования применен для хранения коллекций Animal и IInventory.
* Принцип сегрегации интерфейсов применен в интерфейсах на примере IInventory: есть отдельные интерфейсы для хранения особых видов полей, которые нужны некоторым подклассам IInventory.
* Принцип открытости и закрытости выполнен - пользователю дается возможность взаимодействия только с сервисами, которые имеют налаженную инкапсуляцию. Обмен данными между клиентом и условной "backend частью" происходит через публичные функции.  
* Код активно использует абстракции, лишь в определенных местах подставляя вместо абстрактных объектов - конкретные спецификации (например при регистрации сервисов или при анализе данных).
* Код разбит на множество отдельных подклассов, чтобы выполнить принцип единственной ответственности. В частности, ради выполнения этих приницпов было решено отказаться от класса ветеринарной клиники и зоопарка и использовать вместо этого отдельные классы для каждого действия, осуществляемого с данными.  
Во всех местах применения принципов ООП соблюдается SOLID (например принцип подстановки Барбары Лисков). 

#### Тестирование:
|Часть проекта|Covering|
|--|--|
|DataProcessing|88%|
|ZooObjects|64%|
Total covering: 71%
Остальные части проекта представляют собой GUI-логику и реализацию сервисов, которую не подразумевается покрывать Unit-тестами за ненадобностью.

Юнит-тесты реализованы правильно, в необходимых местах вместо конкретных примеров объектов Animal и IInventory используются специально созданные тестовые подклассы, которые нужны для тестирования взаимодействия отдельных элементов программы с . Также местами применяются Mock тесты для более абстрактного тестирования конкретных сервисов программы.

#### Масштабируемость:
Для выполнения был использован DI-контейнер с множеством сервисов, которые позволяют быстро изменять логику решения на стороне сервера, а также поддерживают легкую масштабируемость и заменяемость старых сервисов на новые. 
